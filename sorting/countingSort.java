/*
Counting Sort is a non-comparative sorting algorithm that works best when the range of possible values ($K$) for each item in an array ($N$) is relatively small [00:06]. It is a stable sorting algorithm, meaning it preserves the relative order of elements with the same value [04:24].2. How the Algorithm Works (Step-by-Step)Step 1: Count Occurrences [00:32]Create a "count array" (of length $K$) to store the frequency of each number in the input array.Example: If the number 1 appears three times, the count array at index 1 will store the value 3.Step 2: Accumulate Sums [01:01]Modify the count array by adding each number to the one to its right cumulatively.This determines how many elements appear before or at a certain value.Step 3: Shift the Array [01:40]Shift the entire count array to the right by one position.Fill the first index (index 0) with 0.The resulting values are the starting indexes for each number in the final sorted array [02:25].Logic: If the starting index for the number 3 is 4, it means there are four items that must appear before 3 in the sorted version [02:56].Step 4: Build the Sorted Array [03:27]Initialize a new output array of the same length as the original.Iterate through the original array. For each element:Look up its starting index in the modified count array.Place the element in the output array at that index.Increment the starting index in the count array by 1. This ensures the next instance of the same number goes into the following slot, maintaining stability [04:00].3. Key PropertiesStability: Different instances of the same value maintain their original relative order. This is important when sorting objects with underlying data (e.g., sorting people by age) [04:33].Time Complexity: $O(N + K)$ [05:22]$N$ = Number of items in the original array.$K$ = Range of possible values.Space Complexity (Auxiliary): $O(N + K)$ [05:42]Requires a new output array of size $N$ and a count array of size $K$.4. When to Use Counting Sort [06:10]Best suited for scenarios where the range of input values ($K$) is not significantly larger than the number of items ($N$).Examples: Sorting grades (0-100), sorting ages (0-120).Less effective when $K$ is much larger than $N$, as it leads to high space complexity.5. ConclusionCounting Sort is a powerful algorithm for specific use cases, particularly when dealing with a limited range of integer values. Its linear time complexity and stability make it a preferred choice in such scenarios [07:00]. */
